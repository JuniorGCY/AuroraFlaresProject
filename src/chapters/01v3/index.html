<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chapter 1 â€” Meteor Run</title>
  <style>
    html,body{
      margin:0;height:100%;background:#000;overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue","Noto Sans",sans-serif
    }

    #hud{
      position:fixed;left:10px;top:10px;z-index:10;color:#e5e7eb;
      background:rgba(0,0,0,.45);border:1px solid #334155;border-radius:12px;
      padding:8px 12px;font:12px/1.35 system-ui;display:flex;gap:12px;align-items:center;
      box-shadow:0 10px 24px rgba(0,0,0,.25);
    }
    #hud strong{font-weight:700}
    #hud kbd{
      background:#0b111f;border:1px solid #1f2a44;border-bottom-color:#17203a;color:#cbd5e1;
      padding:2px 6px;border-radius:6px;font:600 11px/1.2 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas;
      box-shadow:inset 0 -1px 0 #000;
    }

    #topHud{
      position:fixed;left:50%;top:10px;transform:translateX(-50%);
      z-index:11;display:flex;flex-direction:column;align-items:center;gap:8px;
      color:#e5e7eb
    }
    .pill{
      background:rgba(0,0,0,.55);
      border:1px solid #334155;border-radius:999px;
      padding:10px 16px;box-shadow:0 10px 24px rgba(0,0,0,.35);
    }
    #time{
      font-weight:800;letter-spacing:.3px;
      font-size:clamp(16px,3.4vw,22px)
    }
    #score{
      font-weight:600;color:#cfd6e3;
      font-size:clamp(13px,2.6vw,16px)
    }

    #centerHint{
      position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
      color:#e5e7eb;background:rgba(5,12,22,.55);
      border:1px solid #334155;border-radius:14px;
      padding:14px 18px;font:15px/1.35 system-ui;opacity:.97;pointer-events:none;
      z-index:12;white-space:pre-wrap;text-align:center;
      box-shadow:0 12px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04)
    }
    .hide{display:none}

    #touch{
      position:fixed;right:10px;bottom:10px;z-index:10;color:#9fb1cc;
      font:12px/1.2 system-ui;opacity:.8
    }
  </style>
</head>
<body>
  <div id="topHud" aria-live="polite">
    <div id="time" class="pill">0.0s</div>
    <div id="score" class="pill">Score: 0</div>
  </div>

  <div id="hud">
    <span><strong>Controls:</strong> <kbd>â†‘</kbd>/<kbd>â†“</kbd> or move the mouse â€¢ Tap and drag on mobile</span>
  </div>

  <div id="centerHint">Survive the asteroids for 30 seconds!</div>
  <div id="touch" class="pill">Tip: swipe up/down</div>

  <script type="module">
    
    const NEXT_URL = '../01v4/index.html'; 
    const GOAL_SECONDS = 30;

    const WORLD = {
      width: 16, height: 9,
      speed: 8, rocketYSpeed: 12,
      spawnEvery: 0.85, difficultyGrow: 0.025,
      maxAsteroids: 36
    };

    const COLORS = {
      bgSpace: 0x030712,
      starA: 0xbad4ff,
      starB: 0x9bbcff,
      starC: 0xffffff,
      moon: 0xa9b1c6,
      crater: 0x7b8398,
      rocket: 0xe2e8f0,
      fin: 0xf97316,
      windowTrim: 0x38bdf8,
      asteroid: 0x7a6f63,
      engine: 0xff7a1a
    };

    const THREE = await import('https://unpkg.com/three@0.160.1/build/three.module.js');

    let renderer, scene, camera, clock;
    let rocket, moon;
    let running = false;
    let score = 0, survived = 0;
    let targetY = 0;
    let rocketRadius = 0.6, asteroidRadius = 0.8;
    const asteroids = [];
    const pool = [];
    let spawnTimer = 0;
    let shakeT = 0;

    const timeEl  = document.getElementById('time');
    const scoreEl = document.getElementById('score');
    const hintEl  = document.getElementById('centerHint');

    initThree();
    buildScene();
    setTimeout(()=>{ hintEl.classList.add('hide'); }, 2200);
    start();

    function initThree(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(COLORS.bgSpace);
      clock = new THREE.Clock();

      camera = new THREE.OrthographicCamera(
        -WORLD.width/2, WORLD.width/2, WORLD.height/2, -WORLD.height/2, 0.1, 100
      );
      camera.position.z = 10;

      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      const onResize = ()=>{
        const aspect = window.innerWidth / window.innerHeight;
        WORLD.height = WORLD.width / Math.max(aspect, 0.0001);
        camera.top = WORLD.height/2;
        camera.bottom = -WORLD.height/2;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      };
      window.addEventListener('resize', onResize);

      const amb = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(amb);
      const dir = new THREE.DirectionalLight(0xffffff, 0.4);
      dir.position.set(1,1,1);
      scene.add(dir);

      
      window.addEventListener('keydown', (e)=>{
        if(!running) return;
        if(e.key==='ArrowUp'){ targetY = Math.min(targetY + 1.2,  WORLD.height/2 - 0.6); }
        if(e.key==='ArrowDown'){ targetY = Math.max(targetY - 1.2, -WORLD.height/2 + 0.6); }
      });
      window.addEventListener('mousemove', (e)=>{
        if(!running) return;
        const ny = (e.clientY / window.innerHeight) * 2 - 1;
        targetY = THREE.MathUtils.clamp(-ny * (WORLD.height/2 - 0.6), -WORLD.height/2 + 0.6, WORLD.height/2 - 0.6);
      });
      window.addEventListener('touchmove', (e)=>{
        if(!running) return;
        if(e.touches && e.touches[0]){
          const t = e.touches[0];
          const ny = (t.clientY / window.innerHeight) * 2 - 1;
          targetY = THREE.MathUtils.clamp(-ny * (WORLD.height/2 - 0.6), -WORLD.height/2 + 0.6, WORLD.height/2 - 0.6);
        }
      }, { passive:true });
    }

    function buildScene(){
      
      createStarLayer({ count: 650, speed: 0.25, size: 0.030, color: COLORS.starA, twinkle: 0.45, z:-5 });
      createStarLayer({ count: 420, speed: 0.35, size: 0.036, color: COLORS.starB, twinkle: 0.60, z:-3.2 });
      createStarLayer({ count: 260, speed: 0.48, size: 0.044, color: COLORS.starC, twinkle: 0.80, z:-2.2 });
      
      moon = makeMoon();
      moon.position.set(WORLD.width/3, WORLD.height/3 - 1, -1.5);
      scene.add(moon);

      rocket = makeRocket();
      rocket.position.set(-WORLD.width/4, 0, 0);
      rocket.userData.baseRotZ = -Math.PI / 2;
      rocket.rotation.z = rocket.userData.baseRotZ;

      scene.add(rocket);
      targetY = 0;
    }

    function createStarLayer({ count, speed, size, color, twinkle, z }){
      const geo = new THREE.BufferGeometry();
      const positions = new Float32Array(count*3);
      const phases = new Float32Array(count);
      for(let i=0;i<count;i++){
        positions[i*3+0] = THREE.MathUtils.randFloatSpread(WORLD.width*1.7);
        positions[i*3+1] = THREE.MathUtils.randFloatSpread(WORLD.height*1.7);
        positions[i*3+2] = z;
        phases[i] = Math.random()*Math.PI*2;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(positions,3));
      geo.setAttribute('phase', new THREE.BufferAttribute(phases,1));
      const mat = new THREE.PointsMaterial({ size, color, transparent:true, opacity:0.9 });
      const points = new THREE.Points(geo, mat);
      points.userData = { isStars:true, speed, twinkle, baseSize: size, mat };
      scene.add(points);
    }

    function updateStars(dt, t){
      scene.traverse(obj=>{
        if(!obj.userData?.isStars) return;
        const arr = obj.geometry.attributes.position.array;
        for(let i=0;i<arr.length;i+=3){
          arr[i] -= WORLD.speed * obj.userData.speed * dt;
          if(arr[i] < -WORLD.width) arr[i] = WORLD.width;
        }
        obj.geometry.attributes.position.needsUpdate = true;

        const phase = obj.geometry.attributes.phase.array;
        let accum = 0;
        for(let i=0;i<phase.length;i++) accum += phase[i];
        const sparkle = (Math.sin(t*2 + accum*1e-5)*0.5+0.5) * obj.userData.twinkle;
        obj.userData.mat.opacity = 0.75 + sparkle*0.25;
        obj.userData.mat.size = obj.userData.baseSize * (1.0 + sparkle*0.35);
      });
    }

    function makeMoon(){
      const g = new THREE.SphereGeometry(1.25, 28, 18);
      const m = new THREE.MeshStandardMaterial({
        color: COLORS.moon, roughness: 1, metalness: 0,
        emissive: 0x111318, emissiveIntensity: 0.35
      });
      const moon = new THREE.Mesh(g, m);
      moon.userData.isMoon = true;

      const craterMat = new THREE.MeshStandardMaterial({ color: COLORS.crater, roughness: 1 });
      for(let i=0;i<10;i++){
        const r = THREE.MathUtils.randFloat(0.12, 0.28);
        const cg = new THREE.SphereGeometry(r, 12, 8);
        const c = new THREE.Mesh(cg, craterMat);
        const theta = Math.random()*Math.PI*2;
        const phi = Math.random()*Math.PI;
        const R = 1.23;
        c.position.set(
          Math.cos(theta)*Math.sin(phi)*R,
          Math.cos(phi)*R,
          Math.sin(theta)*Math.sin(phi)*R
        );
        c.scale.z = 0.45;
        moon.add(c);
      }
      return moon;
    }

    function makeRocket(){
      const group = new THREE.Group();

      const body = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35, 0.42, 1.5, 20),
        new THREE.MeshStandardMaterial({ color: COLORS.rocket, roughness: 0.7, metalness: 0.1 })
      );
      body.position.set(0, 0, 0);
      group.add(body);

      const nose = new THREE.Mesh(
        new THREE.ConeGeometry(0.35, 0.6, 22),
        new THREE.MeshStandardMaterial({ color: COLORS.rocket, roughness: 0.5, metalness: 0.2 })
      );
      nose.position.set(0, 0.9, 0);
      group.add(nose);

      const win = new THREE.Mesh(
        new THREE.CircleGeometry(0.18, 24),
        new THREE.MeshStandardMaterial({ color: COLORS.windowTrim, emissive: 0x0b8ecf, emissiveIntensity: .7, roughness:.2, metalness:.4 })
      );
      win.position.set(0.02, 0.25, 0.21);
      group.add(win);

      const finGeo = new THREE.BoxGeometry(0.06, 0.5, 0.35);
      const finMat = new THREE.MeshStandardMaterial({ color: COLORS.fin, roughness: 0.8, emissive: 0x1c0f03, emissiveIntensity: .25 });
      const finL = new THREE.Mesh(finGeo, finMat);
      finL.position.set(-0.32, -0.35, 0);
      finL.rotation.z = 0.25;
      const finR = finL.clone(); finR.position.x = 0.32; finR.rotation.z = -0.25;
      group.add(finL, finR);

      const nozzle = new THREE.Mesh(
        new THREE.ConeGeometry(0.22, 0.35, 20),
        new THREE.MeshStandardMaterial({ color: 0x6b7280, roughness: 1 })
      );
      nozzle.rotation.x = Math.PI;
      nozzle.position.set(0, -0.95, 0);
      group.add(nozzle);

      const flame = new THREE.Mesh(
        new THREE.ConeGeometry(0.18, 0.55, 16),
        new THREE.MeshBasicMaterial({ color: COLORS.engine, transparent:true, opacity:0.9, depthWrite:false, blending: THREE.AdditiveBlending })
      );
      flame.rotation.x = Math.PI;
      flame.position.set(0, -1.25, 0);
      flame.userData.isFlame = true;
      group.add(flame);

      const tailCount = 120;
      const tailGeo = new THREE.BufferGeometry();
      tailGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(tailCount*3), 3));
      const tailMat = new THREE.PointsMaterial({ size: 0.06, color: COLORS.engine, transparent:true, opacity:0.9, depthWrite:false, blending:THREE.AdditiveBlending });
      const tail = new THREE.Points(tailGeo, tailMat);
      tail.userData = { isTail:true, head:0 };
      group.add(tail);

      group.userData.isRocket = true;
      return group;
    }

    function updateRocketFX(dt, t){
      if(!rocket) return;
      const flame = rocket.children.find(c=>c.userData?.isFlame);
      if(flame){
        const s = 1 + Math.sin(t*20) * 0.12 + Math.sin(t*8) * 0.06;
        flame.scale.setScalar(s);
        flame.material.opacity = 0.75 + Math.sin(t*12)*0.15;
      }
    }

    function makeAsteroid(){
      let obj = pool.pop();
      if(!obj){
        obj = new THREE.Group();
        const mesh = new THREE.Mesh(
          irregularIcosahedron(0.8, 1, THREE.MathUtils.randFloat(0.18, 0.35)),
          new THREE.MeshStandardMaterial({ color: COLORS.asteroid, roughness: 1 })
        );
        obj.add(mesh);
        obj.userData.isAsteroid = true;
      } else {
        obj.visible = true;
      }
      obj.position.set(WORLD.width/2 + 1.5, THREE.MathUtils.randFloatSpread(WORLD.height - 1.2), 0);
      const s = THREE.MathUtils.randFloat(0.6, 1.35);
      obj.scale.set(s, s, s);
      obj.userData.speed = WORLD.speed * THREE.MathUtils.randFloat(0.85, 1.2);
      obj.userData.spin = new THREE.Vector3(
        THREE.MathUtils.randFloat(-0.6, 0.6),
        THREE.MathUtils.randFloat(-0.6, 0.6),
        THREE.MathUtils.randFloat(-0.6, 0.6),
      );
      scene.add(obj);
      asteroids.push(obj);
    }

    function irregularIcosahedron(radius=1, detail=1, noiseAmp=0.25){
      const g = new THREE.IcosahedronGeometry(radius, detail);
      const pos = g.attributes.position;
      for(let i=0;i<pos.count;i++){
        const v = new THREE.Vector3().fromBufferAttribute(pos, i);
        const n = pseudoNoise(v.x*2.1, v.y*2.1, v.z*2.1);
        v.normalize().multiplyScalar(radius + n*noiseAmp);
        pos.setXYZ(i, v.x, v.y, v.z);
      }
      g.computeVertexNormals();
      return g;
    }

    function pseudoNoise(x,y,z){
      
      return (Math.sin(x*2.3)+Math.sin(y*2.1)+Math.sin(z*2.7)) / 3;
    }

    function updateAsteroids(dt){
      for(let i = asteroids.length-1; i>=0; i--){
        const a = asteroids[i];
        a.position.x -= a.userData.speed * dt;
        a.rotation.x += a.userData.spin.x * dt;
        a.rotation.y += a.userData.spin.y * dt;
        a.rotation.z += a.userData.spin.z * dt;
        if(a.position.x < -WORLD.width/2 - 2){
          scene.remove(a); a.visible = false;
          asteroids.splice(i,1); pool.push(a);
          score += 1; scoreEl.textContent = `Score: ${score}`;
        }
      }
    }

    function boom(where){
      const count = 120;
      const geo = new THREE.BufferGeometry();
      const pos = new Float32Array(count*3);
      const vel = new Float32Array(count*3);
      for(let i=0;i<count;i++){
        pos[i*3+0] = where.x; pos[i*3+1] = where.y; pos[i*3+2] = 0;
        const a = Math.random()*Math.PI*2;
        const s = THREE.MathUtils.randFloat(2, 6);
        vel[i*3+0] = Math.cos(a)*s;
        vel[i*3+1] = Math.sin(a)*s;
        vel[i*3+2] = 0;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      geo.userData.vel = vel;

      const mat = new THREE.PointsMaterial({ size: 0.08, color: COLORS.engine, transparent:true, opacity:1, depthWrite:false, blending:THREE.AdditiveBlending });
      const pts = new THREE.Points(geo, mat);
      pts.userData = { life: 0.9 };
      scene.add(pts);

      pts.userData.isExplosion = true;
    }

    function updateExplosions(dt){
      scene.traverse(obj=>{
        if(!obj.userData?.isExplosion) return;
        obj.userData.life -= dt;
        const pos = obj.geometry.attributes.position.array;
        const vel = obj.geometry.userData.vel;
        for(let i=0;i<pos.length;i+=3){
          pos[i]   += vel[i] * dt;
          pos[i+1] += vel[i+1] * dt - 0.9*dt;
        }
        obj.geometry.attributes.position.needsUpdate = true;
        obj.material.opacity = Math.max(0, obj.userData.life);
        if(obj.userData.life <= 0){
          scene.remove(obj);
        }
      });
    }

    function checkCollision(){
    if(!rocket) return;
    const rp = new THREE.Vector3(); rocket.getWorldPosition(rp);
    for(const a of asteroids){
    const ap = new THREE.Vector3(); a.getWorldPosition(ap);
    if(rp.distanceTo(ap) < (rocketRadius + asteroidRadius)){
      boom(rp);
      screenShake(0.25);
      hintEl.textContent = 'ðŸ’¥ Crashed! Restarting...';
      hintEl.classList.remove('hide');

      setTimeout(()=>{
        location.reload();
      }, 1000);

      running = false; 
      return;
      }
    }
  }

    function start(){
      running = true;
      score = 0; survived = 0;
      spawnTimer = 0; WORLD.speed = 8;
      scoreEl.textContent = 'Score: 0'; timeEl.textContent = '0.0s';
      if(rocket){ rocket.position.y = 0; targetY = 0; }
      clock.getDelta();
      animate();
    }

    function restart(){
      for(const a of asteroids){ scene.remove(a); a.visible = false; pool.push(a); }
      asteroids.length = 0;
      score = 0; scoreEl.textContent = 'Score: 0';
      survived = 0; timeEl.textContent = '0.0s';
      spawnTimer = 0; WORLD.speed = 8;
      if(rocket){ rocket.position.y = 0; targetY = 0; }

      hintEl.textContent = 'Cuidado! VocÃª colidiu.';
      hintEl.classList.remove('hide');
      setTimeout(()=>{
        hintEl.textContent = 'Survive the Meteors';
        hintEl.classList.add('hide');
      }, 900);
    }

    function screenShake(time=0.2){ shakeT = Math.max(shakeT, time); }
    function applyShake(dt){
      if(shakeT > 0){
        shakeT -= dt;
        const k = shakeT*25;
        camera.position.x = Math.random()*0.05*k - 0.025*k;
        camera.position.y = Math.random()*0.05*k - 0.025*k;
      } else {
        camera.position.x = 0; camera.position.y = 0;
      }
    }

    function animate(){
      if(!running) return;
      const dt = clock.getDelta();
      const t = performance.now() * 0.001;

      WORLD.speed += WORLD.difficultyGrow * dt;

      updateStars(dt, t);
      updateRocketFX(dt, t);
      updateExplosions(dt);
      applyShake(dt);

      if(moon){
        moon.position.x -= WORLD.speed * 0.05 * dt;
        if(moon.position.x < -WORLD.width/2 - 3) moon.position.x = WORLD.width/2 + 3;
        moon.rotation.y += 0.05*dt;
      }

      if(rocket){
        const dy = targetY - rocket.position.y;
        rocket.position.y += THREE.MathUtils.clamp(dy, -WORLD.rocketYSpeed*dt, WORLD.rocketYSpeed*dt);
        const bank = THREE.MathUtils.clamp(-dy*0.08, -0.35, 0.35);
        rocket.rotation.z = (rocket.userData.baseRotZ ?? 0) + bank;
      }

      spawnTimer += dt;
      if(spawnTimer >= WORLD.spawnEvery){
        spawnTimer = 0;
        if(asteroids.length < WORLD.maxAsteroids) makeAsteroid();
      }

      updateAsteroids(dt);
      checkCollision();

      survived += dt;
      timeEl.textContent = `${survived.toFixed(1)}s`;
      if(survived >= GOAL_SECONDS){
        running = false; window.location.href = NEXT_URL; return;
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
  </script>
</body>
</html>
