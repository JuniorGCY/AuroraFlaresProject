<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chapter 1</title>
  <style>
    html,body{
      margin:0;height:100%;background:#000;overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue","Noto Sans",sans-serif
    }

    #hud{
      position:fixed;left:10px;top:10px;z-index:10;color:#e5e7eb;
      background:rgba(0,0,0,.45);border:1px solid #334155;border-radius:10px;
      padding:6px 10px;font:12px/1.3 system-ui;display:flex;gap:10px;align-items:center
    }
    #hud strong{font-weight:700}

    #topHud{
      position:fixed;left:50%;top:10px;transform:translateX(-50%);
      z-index:11;display:flex;flex-direction:column;align-items:center;gap:6px;
      color:#e5e7eb
    }
    .pill{
      background:rgba(0,0,0,.55);
      border:1px solid #334155;border-radius:999px;
      padding:8px 14px;box-shadow:0 6px 18px rgba(0,0,0,.35)
    }
    #time{
      font-weight:800;letter-spacing:.3px;
      font-size:clamp(16px,3.4vw,22px)
    }
    #score{
      font-weight:600;color:#cfd6e3;
      font-size:clamp(13px,2.6vw,16px)
    }

    #centerHint{
      position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
      color:#e5e7eb;background:rgba(0,0,0,.35);
      border:1px solid #334155;border-radius:12px;
      padding:12px 16px;font:15px/1.3 system-ui;opacity:.95;pointer-events:none;
      z-index:12;white-space:pre-wrap;text-align:center
    }
    .hide{display:none}
  </style>
</head>
<body>
  <div id="topHud" aria-live="polite">
    <div id="time" class="pill">0.0s</div>
    <div id="score" class="pill">Score: 0</div>
  </div>

  <div id="hud">
    <span><strong>Controls:</strong> ↑/↓ or move the mouse</span>
  </div>

  <div id="centerHint">Survive the Meteors</div>

  <script type="module">
    
    const NEXT_URL = '../01v4/index.html'; 
    const GOAL_SECONDS = 30;

    const PATHS = {
      rocket: './models/Rocketship.glb',
      asteroid: './models/Asteroid.glb',
      moon: './models/Moon.glb',
    };

    const THREE = await import('https://unpkg.com/three@0.160.1/build/three.module.js');
    
    const { GLTFLoader } = await import('https://unpkg.com/three@0.160.1/examples/jsm/loaders/GLTFLoader.js?module');

    let renderer, scene, camera, clock;
    let rocket, asteroidTemplate, moon;
    let running = false;
    let score = 0, survived = 0;
    let targetY = 0;
    let rocketRadius = 0.6, asteroidRadius = 0.8;
    const asteroids = [];
    const pool = [];

    const timeEl  = document.getElementById('time');
    const scoreEl = document.getElementById('score');
    const hintEl  = document.getElementById('centerHint');

    const WORLD = {
      width: 16, height: 9,
      speed: 8, rocketYSpeed: 12,
      spawnEvery: 0.9, difficultyGrow: 0.02,
      maxAsteroids: 30
    };
    let spawnTimer = 0;

    initThree();
    try {
      await loadAssets();
    } catch (e) {
      console.error('Falha no loadAssets:', e);
      hintEl.textContent = 'Carregando placeholders…';
    }

    setTimeout(()=>{ hintEl.classList.add('hide'); }, 3000);

    start();

    function initThree(){
      scene = new THREE.Scene();
      clock = new THREE.Clock();

      camera = new THREE.OrthographicCamera(
        -WORLD.width/2, WORLD.width/2, WORLD.height/2, -WORLD.height/2, 0.1, 100
      );
      camera.position.z = 10;

      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const onResize = ()=>{
        const aspect = window.innerWidth / window.innerHeight;
        WORLD.height = WORLD.width / Math.max(aspect, 0.0001);
        camera.top = WORLD.height/2;
        camera.bottom = -WORLD.height/2;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      };
      new ResizeObserver(onResize).observe(document.body);
      window.addEventListener('resize', onResize);

      const amb = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(amb);

      createStarfieldLayer({ count: 600, speed: 0.25, size: 0.032, color: 0xbad4ff, twinkle: 0.4, z:-5 });
      createStarfieldLayer({ count: 400, speed: 0.35, size: 0.038, color: 0x9bbcff, twinkle: 0.6, z:-3.2 });
      createStarfieldLayer({ count: 250, speed: 0.48, size: 0.045, color: 0xffffff, twinkle: 0.8, z:-2.2 });
    }

    function createStarfieldLayer({ count, speed, size, color, twinkle, z }){
      const geo = new THREE.BufferGeometry();
      const positions = new Float32Array(count*3);
      const phases = new Float32Array(count);
      for(let i=0;i<count;i++){
        positions[i*3+0] = THREE.MathUtils.randFloatSpread(WORLD.width*1.6);
        positions[i*3+1] = THREE.MathUtils.randFloatSpread(WORLD.height*1.6);
        positions[i*3+2] = z;
        phases[i] = Math.random()*Math.PI*2;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(positions,3));
      geo.setAttribute('phase', new THREE.BufferAttribute(phases,1));
      const mat = new THREE.PointsMaterial({ size, color, transparent:true, opacity:0.9 });
      const points = new THREE.Points(geo, mat);
      points.userData = { isStars:true, speed, twinkle, baseSize: size, mat };
      scene.add(points);
    }

    function updateStars(dt, t){
      scene.traverse(obj=>{
        if(!obj.userData?.isStars) return;
        const arr = obj.geometry.attributes.position.array;
        for(let i=0;i<arr.length;i+=3){
          arr[i] -= WORLD.speed * obj.userData.speed * dt;
          if(arr[i] < -WORLD.width) arr[i] = WORLD.width;
        }
        obj.geometry.attributes.position.needsUpdate = true;

        const phase = obj.geometry.attributes.phase.array;
        let accum = 0;
        for(let i=0;i<phase.length;i++) accum += phase[i];
        const sparkle = (Math.sin(t*2 + accum*1e-5)*0.5+0.5) * obj.userData.twinkle;
        obj.userData.mat.opacity = 0.75 + sparkle*0.25;
        obj.userData.mat.size = obj.userData.baseSize * (1.0 + sparkle*0.35);
      });
    }

    async function loadAssets(){
      const loader = new GLTFLoader();

      
      try {
        const gltf = await loader.loadAsync(PATHS.moon);
        moon = gltf.scene;
        moon.scale.set(1.6,1.6,1.6);
        moon.position.set(WORLD.width/3, WORLD.height/3 - 1, -1.5);
        scene.add(moon);
      } catch (e){
        console.warn('Moon GLB falhou — usando esfera.', e);
        const g = new THREE.Mesh(
          new THREE.SphereGeometry(1.2, 24, 16),
          new THREE.MeshStandardMaterial({ color:0x888999, emissive:0x111111, roughness:1 })
        );
        g.position.set(WORLD.width/3, WORLD.height/3 - 1, -1.5);
        moon = g;
        scene.add(moon);
      }

      try {
        const gltf = await loader.loadAsync(PATHS.rocket);
        rocket = gltf.scene;
        rocket.scale.set(0.8,0.8,0.8);
        rocket.rotation.z = 0;
        rocket.position.set(-WORLD.width/4, 0, 0);
        targetY = 0;
        scene.add(rocket);
      } catch (e){
        console.warn('Rocket GLB falhou — usando placeholder.', e);
        const g = new THREE.Mesh(
          new THREE.ConeGeometry(0.6, 2.0, 16),
          new THREE.MeshStandardMaterial({ color:0xff7722, emissive:0x221100 })
        );
        g.rotation.z = Math.PI/2;
        rocket = new THREE.Group();
        rocket.add(g);
        rocket.position.set(-WORLD.width/4, 0, 0);
        scene.add(rocket);
      }

      try {
        const gltf = await loader.loadAsync(PATHS.asteroid);
        asteroidTemplate = gltf.scene;
      } catch (e){
        console.warn('Asteroid GLB falhou — usando placeholder.', e);
        asteroidTemplate = new THREE.Mesh(
          new THREE.IcosahedronGeometry(0.8, 1),
          new THREE.MeshStandardMaterial({ color:0x7a6f63, roughness:1 })
        );
      }
    }

    window.addEventListener('keydown', (e)=>{
      if(!running) return;
      if(e.key==='ArrowUp'){ targetY = Math.min(targetY + 1.2,  WORLD.height/2 - 0.6); }
      if(e.key==='ArrowDown'){ targetY = Math.max(targetY - 1.2, -WORLD.height/2 + 0.6); }
    });
    window.addEventListener('mousemove', (e)=>{
      if(!running) return;
      const ny = (e.clientY / window.innerHeight) * 2 - 1;
      targetY = THREE.MathUtils.clamp(-ny * (WORLD.height/2 - 0.6), -WORLD.height/2 + 0.6, WORLD.height/2 - 0.6);
    });
    window.addEventListener('touchmove', (e)=>{
      if(!running) return;
      if(e.touches && e.touches[0]){
        const t = e.touches[0];
        const ny = (t.clientY / window.innerHeight) * 2 - 1;
        targetY = THREE.MathUtils.clamp(-ny * (WORLD.height/2 - 0.6), -WORLD.height/2 + 0.6, WORLD.height/2 - 0.6);
      }
    }, { passive:true });

    function makeAsteroid(){
      let obj = pool.pop();
      if(!obj){
        obj = new THREE.Group();
        const node = asteroidTemplate.clone(true);
        obj.add(node);
        obj.userData.isAsteroid = true;
      } else {
        obj.visible = true;
      }
      obj.position.set(WORLD.width/2 + 1.5, THREE.MathUtils.randFloatSpread(WORLD.height - 1.2), 0);
      const s = THREE.MathUtils.randFloat(0.6, 1.3);
      obj.scale.set(s, s, s);
      obj.userData.speed = WORLD.speed * THREE.MathUtils.randFloat(0.85, 1.2);
      obj.userData.spin = new THREE.Vector3(
        THREE.MathUtils.randFloat(-0.6, 0.6),
        THREE.MathUtils.randFloat(-0.6, 0.6),
        THREE.MathUtils.randFloat(-0.6, 0.6),
      );
      scene.add(obj);
      asteroids.push(obj);
    }

    function updateAsteroids(dt){
      for(let i = asteroids.length-1; i>=0; i--){
        const a = asteroids[i];
        a.position.x -= a.userData.speed * dt;
        a.rotation.x += a.userData.spin.x * dt;
        a.rotation.y += a.userData.spin.y * dt;
        a.rotation.z += a.userData.spin.z * dt;
        if(a.position.x < -WORLD.width/2 - 2){
          scene.remove(a); a.visible = false;
          asteroids.splice(i,1); pool.push(a);
          score += 1; scoreEl.textContent = `Score: ${score}`;
        }
      }
    }

    function checkCollision(){
      if(!rocket) return;
      const rp = new THREE.Vector3(); rocket.getWorldPosition(rp);
      for(const a of asteroids){
        const ap = new THREE.Vector3(); a.getWorldPosition(ap);
        if(rp.distanceTo(ap) < (rocketRadius + asteroidRadius)){
          restart(); return;
        }
      }
    }

    function start(){
      running = true;
      score = 0; survived = 0;
      spawnTimer = 0; WORLD.speed = 8;
      scoreEl.textContent = 'Score: 0'; timeEl.textContent = '0.0s';
      if(rocket){ rocket.position.y = 0; targetY = 0; }
      clock.getDelta();
      animate();
    }

    function restart(){
      for(const a of asteroids){ scene.remove(a); a.visible = false; pool.push(a); }
      asteroids.length = 0;
      score = 0; scoreEl.textContent = 'Score: 0';
      survived = 0; timeEl.textContent = '0.0s';
      spawnTimer = 0; WORLD.speed = 8;
      if(rocket){ rocket.position.y = 0; targetY = 0; }

      hintEl.textContent = 'Careful! You collided.';
      hintEl.classList.remove('hide');
      setTimeout(()=>{
        hintEl.textContent = 'Survive the Meteors';
        hintEl.classList.add('hide');
      }, 900);
    }

    function animate(){
      if(!running) return;
      const dt = clock.getDelta();
      const t = performance.now() * 0.001;

      WORLD.speed += WORLD.difficultyGrow * dt;
      updateStars(dt, t);

      if(moon){
        moon.position.x -= WORLD.speed * 0.05 * dt;
        if(moon.position.x < -WORLD.width/2 - 3) moon.position.x = WORLD.width/2 + 3;
      }

      if(rocket){
        const dy = targetY - rocket.position.y;
        rocket.position.y += THREE.MathUtils.clamp(dy, -WORLD.rocketYSpeed*dt, WORLD.rocketYSpeed*dt);
        rocket.rotation.z = THREE.MathUtils.clamp(-dy*0.08, -0.35, 0.35);
      }

      spawnTimer += dt;
      if(spawnTimer >= WORLD.spawnEvery){
        spawnTimer = 0;
        if(asteroids.length < WORLD.maxAsteroids) makeAsteroid();
      }

      updateAsteroids(dt);
      checkCollision();

      survived += dt;
      timeEl.textContent = `${survived.toFixed(1)}s`;
      if(survived >= GOAL_SECONDS){
        running = false; window.location.href = NEXT_URL; return;
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
  </script>
</body>
</html>
